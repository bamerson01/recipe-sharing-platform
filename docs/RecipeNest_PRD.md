# Cover
**Product / Project:** RecipeNest — Social Recipe Collections (CRUD)

**Doc Owner:** Brady Amerson (with GPT-5 Thinking as spec co-author)

**Version:** v1.0 (MVP)

**Date:** Aug 20, 2025

**Status:** Draft (ready to implement)

**Reviewers:** You / Course mentors

---

# 1) Vision
**What we’re building:** A minimalist, social recipe app where people create, browse, and share recipes. Think “Notion-simple recipes” with likes and search.

**The problem:** People keep recipes across screenshots, notes, and blogs. They want a clean place to save their own, discover others, and quickly cook.

**Who it’s for:** Home cooks and food-curious users who want fast CRUD, clean mobile UI, and social signals (likes) to surface good stuff.

**Experience goals:**
- Fast, delightful, mobile-first UI
- Dead-simple editor for ingredients & steps
- Useful search + category filters
- Frictionless like & share
- Private/draft until ready; public when published

**Success signals:** 7-day retention on creators, avg. 3+ recipes/user in 30 days, >30% of recipe views from search/browse, median TTFB <150ms on Vercel.

**Non-goals (MVP):** Comments, follows/feeds, meal plans, shopping lists, nutrition breakdown, multi-tenant org billing.

---

# 2) Core Features (MVP)
1) **Auth** via Supabase: sign up / sign in / sign out (email+password; optional OAuth later)
2) **Profile** (display name, avatar)
3) **Recipe CRUD** (create, edit, delete, publish/draft)
4) **Ingredients & Steps** structured fields
5) **Image upload** to Supabase Storage (cover image per recipe)
6) **Likes** (1/user/recipe; toggle; like count shown in cards and detail)
7) **Search** (keyword across title/ingredients) + **Category filter**
8) **Archive (Explore) page** with cards (image, title, like count)
9) **Recipe detail page** (full content; shareable public slug)
10) **Landing page** (hero, CTA to sign up, featured/top liked)

**Nice-to-haves (Phase 2):** Bookmarks, import from URL, AI ingredient extractor, share-to-social OG tags, user collections, reports/analytics.

---

# 3) Information Architecture & UX
**Top-level nav:** Landing → Explore (Archive) → New Recipe → My Recipes → Profile → Sign In/Out

**Pages & sections**
- **Landing**: Hero + search input; Featured (top liked), CTA, how-it-works.
- **Explore (Archive)**: Grid of cards (image, title, like count). Filters: Category multi-select; Sort: Most liked / Newest.
- **Recipe detail**: Cover image, title, author, like button & count, categories, ingredients list, step-by-step instructions, share button.
- **New/Edit recipe**: Title, categories (multi), image upload, ingredients (dynamic list), steps (reorderable), visibility (draft/public), Save/Publish.
- **My Recipes (dashboard)**: Table/list with inline edit/delete; status badges.
- **Auth**: Email+password; password reset. (OAuth optional later.)
- **Profile**: Display name, avatar; my public profile route /u/:username

**Design principles**
- Clear hierarchy, big readable type, zero clutter
- Accessible (WCAG AA), keyboard-first flows
- Skeleton loaders; optimistic UI for likes
- Light/dark theme

---

# 4) Tech Stack
**Frontend**: Next.js 14 (App Router), TypeScript, React Server Components, Tailwind CSS, shadcn/ui, lucide-react, react-hook-form + zod

**Backend-as-a-service**: Supabase (Auth, Postgres, RLS, Storage)

**Search**: Postgres full-text search (tsvector + GIN), optional pg_trgm

**Deployment**: Vercel (preview + prod), Vercel Analytics

**CI**: Vercel PR previews; typecheck & lint on pre-commit (biome/eslint) 

**State**: Server Components + minimal client state; SWR/React Query optional

**Image handling**: Supabase Storage signed URLs; next/image for display

---

# 5) Data Model (Supabase)
**Notes**
- Enable RLS on all tables.
- Use `auth.users` (Supabase managed) for identity; mirror to `profiles` table for public fields.
- Store cover image path in `recipes.image_path` (points to Supabase Storage).
- Enforce one-like-per-user-per-recipe via unique constraint.
- Search via `recipes.search_vector` (tsvector) + GIN index.

## Tables
### profiles
- `id` UUID PK (matches `auth.users.id`)
- `username` TEXT UNIQUE NULLABLE
- `display_name` TEXT
- `avatar_url` TEXT
- `created_at` TIMESTAMPTZ DEFAULT now()

### categories
- `id` BIGINT PK GENERATED BY DEFAULT AS IDENTITY
- `name` TEXT UNIQUE NOT NULL
- `slug` TEXT UNIQUE NOT NULL
- `created_at` TIMESTAMPTZ DEFAULT now()

### recipes
- `id` BIGINT PK GENERATED BY DEFAULT AS IDENTITY
- `author_id` UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE
- `title` TEXT NOT NULL
- `slug` TEXT UNIQUE NOT NULL
- `summary` TEXT
- `image_path` TEXT  -- Supabase Storage key
- `is_public` BOOLEAN DEFAULT false
- `like_count` INT DEFAULT 0
- `search_vector` TSVECTOR
- `created_at` TIMESTAMPTZ DEFAULT now()
- `updated_at` TIMESTAMPTZ DEFAULT now()

### recipe_ingredients
- `id` BIGINT PK GENERATED BY DEFAULT AS IDENTITY
- `recipe_id` BIGINT REFERENCES recipes(id) ON DELETE CASCADE
- `position` INT NOT NULL
- `text` TEXT NOT NULL

### recipe_steps
- `id` BIGINT PK GENERATED BY DEFAULT AS IDENTITY
- `recipe_id` BIGINT REFERENCES recipes(id) ON DELETE CASCADE
- `position` INT NOT NULL
- `text` TEXT NOT NULL

### recipe_categories (join)
- `recipe_id` BIGINT REFERENCES recipes(id) ON DELETE CASCADE
- `category_id` BIGINT REFERENCES categories(id) ON DELETE CASCADE
- **PK** (`recipe_id`, `category_id`)

### likes
- `id` BIGINT PK GENERATED BY DEFAULT AS IDENTITY
- `recipe_id` BIGINT REFERENCES recipes(id) ON DELETE CASCADE
- `user_id` UUID REFERENCES profiles(id) ON DELETE CASCADE
- `created_at` TIMESTAMPTZ DEFAULT now()
- **UNIQUE** (`recipe_id`, `user_id`)

## SQL (schema & search)
```sql
-- Extensions
create extension if not exists pg_trgm;

-- profiles mirrors auth.users
create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  username text unique,
  display_name text,
  avatar_url text,
  created_at timestamptz default now()
);

create table if not exists public.categories (
  id bigserial primary key,
  name text unique not null,
  slug text unique not null,
  created_at timestamptz default now()
);

create table if not exists public.recipes (
  id bigserial primary key,
  author_id uuid not null references public.profiles(id) on delete cascade,
  title text not null,
  slug text unique not null,
  summary text,
  image_path text,
  is_public boolean default false,
  like_count int default 0,
  search_vector tsvector,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists public.recipe_ingredients (
  id bigserial primary key,
  recipe_id bigint references public.recipes(id) on delete cascade,
  position int not null,
  text text not null
);

create table if not exists public.recipe_steps (
  id bigserial primary key,
  recipe_id bigint references public.recipes(id) on delete cascade,
  position int not null,
  text text not null
);

create table if not exists public.recipe_categories (
  recipe_id bigint references public.recipes(id) on delete cascade,
  category_id bigint references public.categories(id) on delete cascade,
  primary key (recipe_id, category_id)
);

create table if not exists public.likes (
  id bigserial primary key,
  recipe_id bigint references public.recipes(id) on delete cascade,
  user_id uuid references public.profiles(id) on delete cascade,
  created_at timestamptz default now(),
  unique (recipe_id, user_id)
);

-- Search vector + indexes
create index if not exists recipes_search_gin on public.recipes using gin(search_vector);
create index if not exists recipes_title_trgm on public.recipes using gin (title gin_trgm_ops);

-- Keep search_vector fresh
create or replace function public.set_recipes_search_vector() returns trigger as $$
begin
  new.search_vector :=
    to_tsvector('simple', coalesce(new.title,'') || ' ' || coalesce(new.summary,''));
  return new;
end; $$ language plpgsql;

create trigger recipes_tsv before insert or update
on public.recipes for each row execute procedure public.set_recipes_search_vector();

-- Auto-update updated_at
create or replace function public.touch_updated_at() returns trigger as $$
begin
  new.updated_at := now();
  return new;
end; $$ language plpgsql;

create trigger recipes_touch before update on public.recipes
for each row execute procedure public.touch_updated_at();

-- Like count maintenance
create or replace function public.bump_like_count() returns trigger as $$
begin
  if TG_OP = 'INSERT' then
    update public.recipes set like_count = like_count + 1 where id = new.recipe_id;
    return new;
  elsif TG_OP = 'DELETE' then
    update public.recipes set like_count = like_count - 1 where id = old.recipe_id;
    return old;
  end if;
  return null;
end; $$ language plpgsql;

create trigger likes_count_ins after insert on public.likes
for each row execute procedure public.bump_like_count();

create trigger likes_count_del after delete on public.likes
for each row execute procedure public.bump_like_count();
```

## RLS Policies
> Enable RLS: `alter table <table> enable row level security;`

**profiles**
- Select: anyone can read public profiles
- Insert: only user can create their row (`auth.uid() = id`)
- Update: only owner (`auth.uid() = id`)

**recipes**
- Select: public if `is_public = true` OR `author_id = auth.uid()`
- Insert: authenticated users
- Update/Delete: only owner

**recipe_ingredients / recipe_steps / recipe_categories**
- Select: visible if parent recipe visible to requester
- Insert/Update/Delete: only if requester owns the parent recipe

**likes**
- Select: anyone
- Insert: auth users; one per (user, recipe)
- Delete: only owner of like or recipe author (optional)

**Example policy SQL**
```sql
-- PROFILES
alter table public.profiles enable row level security;
create policy profiles_read on public.profiles for select using (true);
create policy profiles_insert on public.profiles for insert with check (auth.uid() = id);
create policy profiles_update on public.profiles for update using (auth.uid() = id);

-- RECIPES
alter table public.recipes enable row level security;
create policy recipes_read on public.recipes for select using (
  is_public = true or author_id = auth.uid()
);
create policy recipes_insert on public.recipes for insert with check (auth.role() = 'authenticated');
create policy recipes_update on public.recipes for update using (author_id = auth.uid());
create policy recipes_delete on public.recipes for delete using (author_id = auth.uid());

-- INGREDIENTS
alter table public.recipe_ingredients enable row level security;
create policy ing_read on public.recipe_ingredients for select using (
  exists (select 1 from public.recipes r where r.id = recipe_id and (r.is_public or r.author_id = auth.uid()))
);
create policy ing_write on public.recipe_ingredients for all using (
  exists (select 1 from public.recipes r where r.id = recipe_id and r.author_id = auth.uid())
) with check (
  exists (select 1 from public.recipes r where r.id = recipe_id and r.author_id = auth.uid())
);

-- STEPS
alter table public.recipe_steps enable row level security;
create policy steps_read on public.recipe_steps for select using (
  exists (select 1 from public.recipes r where r.id = recipe_id and (r.is_public or r.author_id = auth.uid()))
);
create policy steps_write on public.recipe_steps for all using (
  exists (select 1 from public.recipes r where r.id = recipe_id and r.author_id = auth.uid())
) with check (
  exists (select 1 from public.recipes r where r.id = recipe_id and r.author_id = auth.uid())
);

-- RECIPE_CATEGORIES
alter table public.recipe_categories enable row level security;
create policy rc_read on public.recipe_categories for select using (
  exists (select 1 from public.recipes r where r.id = recipe_id and (r.is_public or r.author_id = auth.uid()))
);
create policy rc_write on public.recipe_categories for all using (
  exists (select 1 from public.recipes r where r.id = recipe_id and r.author_id = auth.uid())
) with check (
  exists (select 1 from public.recipes r where r.id = recipe_id and r.author_id = auth.uid())
);

-- LIKES
alter table public.likes enable row level security;
create policy likes_read on public.likes for select using (true);
create policy likes_insert on public.likes for insert with check (auth.role() = 'authenticated');
create policy likes_delete on public.likes for delete using (user_id = auth.uid());
```

## Storage (Supabase)
- Bucket: `recipe-images` (public read; writes only by auth users)
- Store cover image at `recipes/<author_id>/<recipe_id>.jpg`
- Keep only compressed, reasonably sized images; generate signed URLs in app.

---

# 6) Search & Filtering
**Keyword search**: query `recipes.search_vector @@ plainto_tsquery($q)` OR `ILIKE` fallback on title; combine with `pg_trgm` for fuzzy.

**Filters**:
- Category (multi): `exists in recipe_categories`
- Sort: `like_count desc` (top), `created_at desc` (new)
- Pagination: cursor-based (`created_at`/`id`)

---

# 7) Step-by-Step Implementation Guide
> Order of work so you can ship MVP fast and iterate.

## A) Project & UI Bootstrap
1. Create Next.js 14 app (TS + Tailwind) and set up shadcn/ui.
2. Global layout, theme, and base components (Button, Card, Input, Textarea, Badge, Dialog, Skeleton).
3. Build **Landing** and **Explore** stub pages + shared RecipeCard.

## B) Supabase Setup
4. Create Supabase project; get `NEXT_PUBLIC_SUPABASE_URL` & `SUPABASE_SERVICE_ROLE_KEY` (service role used only in secure env / migrations).
5. Run SQL schema above (via SQL editor or migration tool). Enable RLS.
6. Create Storage bucket `recipe-images`; set public read policy; restrict writes to auth users.
7. Seed `categories` (e.g., Breakfast, Lunch, Dinner, Dessert, Vegan, Gluten-Free).

## C) Auth & Profiles
8. Install `@supabase/supabase-js` and `@supabase/ssr`. Wire up server-side client in Next middleware/route handlers.
9. Implement email+password auth UI (sign up, sign in, sign out) and session handling. On first login, insert row in `profiles`.

## D) Recipes CRUD
10. **Create/Edit recipe** page: react-hook-form + zod; dynamic arrays for ingredients & steps; image upload to Storage; generate slug from title.
11. Persist recipe + related rows in a single transaction-like flow (create recipe → insert ingredients/steps → upsert categories join).
12. **My Recipes** page: list with status (draft/public), edit/delete actions.
13. **Recipe detail** page: fetch by slug; show like button (optimistic), ingredient/step lists, OG tags for sharing.

## E) Likes, Search, Archive
14. Like toggle: insert/delete in `likes`; handle unique constraint; update UI optimistically.
15. Explore (Archive) page: search input + category filter; SSR the first page; client-side filters; infinite scroll or pager.
16. Add sorting controls (Top / Newest). Ensure GIN index is used; test EXPLAIN.

## F) Polish & Deploy
17. 404/empty states, loading skeletons, toasts; mobile and desktop passes.
18. Lighthouse pass: image sizes, caching headers, next/image; meta tags.
19. Add Vercel Analytics. Configure env vars in Vercel Project.
20. Deploy to Vercel: production + preview; test auth callbacks domain.

---

# 8) API & Routing Notes (Next.js App Router)
- Use **Server Actions** for create/update/delete where possible (reduces client keys exposure).
- For queries, prefer **RSC** (fetch on server using supabase SSR client) → stream to client.
- Protect routes: middleware checks session for `/app/*`; public routes for Landing, Explore, Recipe detail of public recipes.

---

# 9) Acceptance Criteria (MVP)
- User can sign up, sign in, sign out.
- User can create a draft recipe with title, image, ingredients, steps; save & publish.
- Public recipe detail reachable via `/r/:slug` without auth.
- Explore shows grid cards: image, title, like count; clicking opens detail.
- Search by keyword returns relevant recipes; category filter narrows results.
- Like button toggles and count updates without refresh; one like per user enforced.
- Owner can edit or delete their recipe; others cannot.
- Basic SEO tags present (title/desc/OG), image optimized.
- All RLS policies verified (no data leaks).

---

# 10) Security, Privacy, RLS Checklist
- RLS enabled on all tables; policies tested with anon vs auth sessions.
- Service role key **never** used in client; only in server actions or migrations.
- Storage writes: only auth users; read via signed URLs or public bucket w/ cache.
- Validation with zod on all user inputs.

---

# 11) Performance & Accessibility
- GIN indexes for search; paginated queries; avoid N+1 (batch load children).
- next/image with width/height; compress to < 150KB where possible.
- Lighthouse ≥ 90 on Perf/Best/SEO; Axe pass for key screens; keyboard and screen reader labels.

---

# 12) Analytics & Monitoring
- Vercel Analytics basic traffic
- (Optional) Logtail/Sentry for errors
- Track create recipe, publish, like events (custom `window.plausible` or Vercel Web Analytics events)

---

# 13) Deployment
- Envs in Vercel: `NEXT_PUBLIC_SUPABASE_URL`, `NEXT_PUBLIC_SUPABASE_ANON_KEY`, `SUPABASE_SERVICE_ROLE_KEY` (server only), `NEXT_PUBLIC_SITE_URL`
- Set Supabase Auth redirect URLs to Vercel preview + prod domains
- Run SQL/migrations in prod; seed categories

---

# 14) Future / Complex Features (Phase 2+)
- **Bookmarks** and **Collections** per user
- **Import from URL** (scrape + parse schema.org/Recipe)
- **AI Assist**: turn pasted text into structured ingredients/steps; unit normalization
- **Comments & Ratings** separate from likes
- **User follows** + personalized feed
- **Nutrition estimation** via 3rd-party db
- **Share image generator** (OG images)

---

# 15) Open Questions
- Do we want OAuth (Google/Apple) in MVP? (default: later)
- Are categories curated (admin-only) or user-addable? (default: curated in MVP)
- Keep public bucket or signed URLs for images? (default: public read, controlled write)

---

# 16) Quick Task Breakdown (Cursor-friendly)
- [ ] Next.js + Tailwind scaffold; shadcn init; base components
- [ ] Supabase project + env; run schema SQL; enable RLS; seed categories
- [ ] Auth flows + profile sync
- [ ] Recipe editor (form + upload + slug)
- [ ] Detail page (public), likes
- [ ] Explore with search/filter/sort + pagination
- [ ] My Recipes dashboard
- [ ] Polish (SEO, a11y, perf), deploy to Vercel

---

# 17) Example Category Seeds
- Breakfast, Lunch, Dinner, Dessert, Snacks, Vegan, Vegetarian, Gluten-Free, Keto, Paleo, Quick, Slow Cooker, One-Pot, Air Fryer

---

# 18) Glossary
- **Archive**: Explore grid of public recipes
- **Public**: visible to all; **Draft**: visible to owner only
- **Like**: binary per user/recipe; used for ranking

---

*End of PRD v1.0*
