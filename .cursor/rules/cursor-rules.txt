Cursor Project Rules — RecipeNest (Next.js + Supabase)

You are an expert in TypeScript, Next.js App Router (v14+), React, Supabase (Auth/Postgres/Storage/RLS), TailwindCSS, and shadcn/ui. You build secure, accessible, high-quality web apps with minimal client-side state and clean server boundaries.

Mission & Scope

Build RecipeNest: a social recipe CRUD app with auth, image uploads, likes, search, and category filters.

Ship a production-ready MVP deployed on Vercel, backed by Supabase.

Follow the PRD in this repo. If something is unclear, make the safest assumption and proceed.

Code Style & Structure

Write concise, modular TypeScript. No classes. Prefer small pure functions.

Strict TypeScript: no any/unknown unless unavoidable; no type assertions if you can infer.

Use descriptive names (e.g., isLoading, hasError, handleSubmit).

Favor early returns and guard clauses. Keep control flow shallow.

Do not duplicate logic; factor reusable utilities.

Document exported functions/components with brief TSDoc/JSDoc when intent isn’t obvious.

Formatting: Prettier + ESLint/biome; keep imports sorted; remove dead code.

Directory Conventions
app/                   # Next.js App Router
  (marketing)/         # Landing/public pages
  (app)/               # Auth'd app routes (protected)
  explore/             # Public archive & search
  r/[slug]/            # Public recipe detail
  api/                 # Route handlers (server-only)
components/            # UI components (shadcn-based), subfolders by domain
lib/                   # server & shared libs (db, auth, validation, utils)
lib/db/                # Supabase server client, queries, SQL helpers
lib/validation/        # zod schemas
lib/utils/             # cn(), slugify, pagination helpers
styles/                # globals.css (Tailwind base)
types/                 # shared interfaces
scripts/               # seed/migration helpers (server-only)
public/                # static assets


Named exports for components/utilities.

Lowercase-dash for directories (e.g., recipe-card).

Keep files ≤ ~200–300 LOC; split into subcomponents.

React, UI & Styling

Use shadcn/ui + Tailwind. No custom CSS files unless absolutely needed.

Use server components by default. Mark client components with "use client" only when needed (forms, event handlers).

Co-locate small client subcomponents inside the page/component directory when they are only used there.

Conditional classes via a cn() helper (clsx/tailwind-merge). No string concatenation.

Accessibility: label form controls, use semantic HTML, keyboard focus states, aria-* where appropriate. All interactive elements must be reachable by keyboard.

Support dark mode via Tailwind.

Forms & Validation

Use react-hook-form + zodResolver with zod schemas from lib/validation.

Display inline errors, disable submit while pending, optimistic updates only where safe (e.g., likes).

Supabase (Auth, DB, Storage)

Use @supabase/supabase-js and SSR helpers. Create server client only in server contexts (route handlers, server actions, RSC).

Never expose the service role key to the client. Use it only in scripts/migrations or secure server code.

Respect RLS policies. Assume the database enforces access; do not bypass with service role in runtime web requests.

Schema source of truth is scripts/sql/schema.sql. Mutations to schema go through SQL migrations.

Storage bucket: recipe-images. Public read; writes restricted to authenticated users.

Server/Client Boundaries

Data fetching/mutations:

Use Server Actions or route handlers for writes.

Use RSC/server for reads, stream results to clients.

Do not initialize Supabase client in global client-side providers for data fetching.

Likes & Concurrency

Enforce one-like-per-user-per-recipe with a unique DB constraint.

Update like counts via DB trigger; do not trust client increments.

UI uses optimistic toggle but reconciles on failure.

Data & Search

Use Postgres tsvector + GIN for keyword search over title + summary.

Category filter via join table; prefer server-side filtering.

Pagination: cursor-based on created_at/id.

API Design

Route handlers under app/api/* are server-only and must validate input with zod.

Return typed JSON (as const where appropriate). Handle and log errors; do not leak stack traces to clients.

Prefer Server Actions for form posts when feasible.

Security & Privacy

RLS enabled on all tables; policies match PRD. Test with anon vs auth sessions.

Sanitize/validate all user input. Never trust client data.

Do not log secrets or PII. Centralize logging utilities.

CSRF: Server Actions/Next forms are preferred; if using fetch, include proper auth context.

Content Security Policy: rely on Next.js defaults; avoid dangerouslySetInnerHTML.

Performance

Optimize Web Vitals (LCP/CLS):

Use next/image with width/height and responsive sizes.

Stream server components; suspense client boundaries.

Avoid unnecessary client state; prefer derived props.

Database: use indexed queries; avoid N+1 by batching child fetches.

Error Handling & Observability

Validate early with zod and return typed errors.

Use error boundaries for client islands.

Optional: integrate Sentry/Logtail. In errors, show friendly messages.

Testing

Vitest for unit tests.

@testing-library/react for component tests (client parts).

Playwright for critical e2e (auth, create recipe, like flow, search).

Seed ephemeral test data via Supabase SQL scripts.

Environment & Secrets

Required env vars:

NEXT_PUBLIC_SUPABASE_URL

NEXT_PUBLIC_SUPABASE_ANON_KEY

SUPABASE_SERVICE_ROLE_KEY (server-only)

NEXT_PUBLIC_SITE_URL

Configure allowed redirect URLs in Supabase Auth to Vercel preview + prod.

Never access server-only env vars in client code.

Git & Reviews

Small PRs with clear titles (type/scope): feat(recipes): create editor form.

Checklist per PR:

 Types strict, no any

 RSC by default; client only where needed

 Inputs validated with zod

 RLS respected (tested anon vs auth)

 a11y labels and focus states

 Lighthouse ≥ 90 on key pages

Output Expectations (when AI generates code)

Provide complete, runnable files with correct imports and exports.

Include types and zod schemas for inputs.

Use Tailwind for all styling; shadcn/ui components where suitable.

Include loading and empty states.

No placeholders or TODOs. If something is not implementable, state it clearly.

Patterns & Snippets
Supabase Server Client (RSC / Server Action)
// lib/db/server.ts
import { cookies } from 'next/headers';
import { createServerClient } from '@supabase/ssr';
import { Database } from '@/types/supabase';

export function getServerSupabase() {
  const cookieStore = cookies();
  return createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get: (name: string) => cookieStore.get(name)?.value,
      },
    }
  );
}

Server Action Example
// app/(app)/recipes/_actions/create-recipe.ts
'use server';
import { z } from 'zod';
import { getServerSupabase } from '@/lib/db/server';
import { revalidatePath } from 'next/cache';

const RecipeInput = z.object({
  title: z.string().min(2),
  summary: z.string().optional(),
  isPublic: z.boolean().default(false),
});

export async function createRecipe(formData: FormData) {
  const parsed = RecipeInput.safeParse({
    title: formData.get('title'),
    summary: formData.get('summary') ?? undefined,
    isPublic: (formData.get('isPublic') as string) === 'on',
  });
  if (!parsed.success) return { ok: false, errors: parsed.error.flatten() } as const;

  const supabase = getServerSupabase();
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) return { ok: false, message: 'Unauthorized' } as const;

  const { error } = await supabase
    .from('recipes')
    .insert({ title: parsed.data.title, summary: parsed.data.summary, is_public: parsed.data.isPublic, author_id: user.id });
  if (error) return { ok: false, message: 'Failed to create' } as const;

  revalidatePath('/my');
  return { ok: true } as const;
}

cn() Utility
// lib/utils/cn.ts
import { clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';
export function cn(...inputs: unknown[]) {
  return twMerge(clsx(inputs));
}

Prohibited / Caution

No service role key in any runtime that can be requested by the browser.

No schema changes outside migration scripts.

No global client-side data fetching via Supabase for protected data.

Use dangerouslySetInnerHTML only with escaped/sanitized content (prefer not at all).

Runbook

pnpm dev → local dev

pnpm lint / pnpm typecheck / pnpm test

pnpm db:push → run SQL migration scripts

Vercel: set env vars; connect Git; preview deploys per PR

Work Completed log

Always update summary_work_completed.md at the repo root for any major feature, significant fix, architecture decision, or phase change.

Purpose

Context Preservation – never lose track of what we’ve built

Progress Tracking – clear view of completed vs pending

Technical Reference – key files, components, and decisions

Issue Resolution – documented fixes

Future Planning – cues for upcoming phases

How to log (concise + required)

Prepend a new entry (latest at top).

Use the template below and always include PRD variance notes:

NEW FEATURE — if you added anything not in RecipeNest_PRD.md (1–3 sentence description).

CHANGED FEATURE — if you modified something listed in RecipeNest_PRD.md (brief before/after + rationale and PRD section reference).

Template

## YYYY-MM-DD HH:mm (America/Denver) — <Short Title>

**Scope:** <feature|bugfix|refactor>
**Files:** <relative paths>
**Why:** <problem being solved>
**What changed:**
- <bulleted highlights>

**Testing:** <manual/e2e/unit; env>
**Impact:** <perf|SEO|DB schema|RLS|API|UX|None>

### PRD Variance
- NEW FEATURE: <name> — <1–3 sentence description>.
- CHANGED FEATURE: <name> — PRD §<section>. Before: <brief>. After: <brief>. Rationale: <why>.


End of Cursor Rules